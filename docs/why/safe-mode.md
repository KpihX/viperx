# Why Safe Mode?

## The Philosophy

**ViperX never overwrites your work without permission.**

This isn't just a feature‚Äîit's a core design principle that shapes every command.

**The Rule:**
> When in doubt, stop and ask. Never silently destroy user data.

## The Problem: Destructive Defaults

### Other Tools (Common Pattern)

**Typical scaffold/generator behavior:**

```bash
$ scaffold-tool init myproject
Creating project...
‚úì Created myproject/
‚úì Created src/
‚úì Created README.md  ‚ö†Ô∏è  Overwrote existing file!
‚úì Created .gitignore ‚ö†Ô∏è  Overwrote existing file!
‚úì Created setup.py   ‚ö†Ô∏è  Deleted your custom build script!

Done!
```

**What just happened?**
- Your carefully crafted README? **Gone.**
- Your custom .gitignore with 50 patterns? **Replaced with generic template.**
- Your setup.py with special build steps? **Destroyed.**

**No warning. No confirmation. No undo.**

### Real-World Horror Stories

#### Story 1: The Lost README

**Developer experience:**
```bash
$ cd my-existing-project/
$ ls
README.md  # 3 months of documentation
src/

$ cool-generator init
# ... runs ...

$ cat README.md
# My Project
Generated by cool-generator

TODO: Add description
```

**3 months of docs? Gone. No backup. Not in git yet.**

#### Story 2: The Production Config

**DevOps scenario:**
```bash
$ cd production-service/
$ ls
config.yaml  # Production database URLs, API keys, etc.

$ framework-cli setup
Initializing...
‚úì Created config.yaml

$ cat config.yaml
# Default configuration
database: localhost
api_key: YOUR_KEY_HERE
```

**Production credentials? Overwritten with template. Service down.**

#### Story 3: The Silent Git Deletion

**Developer workflow:**
```bash
$ git clone company/project
$ cd project
$ ls -la
.git/
src/
README.md

$ project-tool init .
Initializing...
‚úì Cleaned directory
‚úì Created new project structure

$ git status
fatal: not a git repository
```

**Entire git history? Deleted. "Cleaned" meant "wiped everything."**

## ViperX's Safe Mode Approach

### 1. Never Overwrite Existing Files

**ViperX behavior:**

```bash
$ cd my-existing-project/
$ ls
README.md  # Your existing README

$ viperx new mypackage
Creating Python package 'mypackage'...

‚úì Created src/
‚úì Created src/mypackage/
‚úì Created src/mypackage/__init__.py
‚ö†Ô∏è  SKIPPED: README.md (file already exists)
‚úì Created pyproject.toml

‚ö†Ô∏è  Conflicts detected:
  - README.md exists (not overwritten)

Would you like to:
  1. Keep existing files (safe)
  2. Overwrite with templates (--force)
  3. Review conflicts one by one

Choice [1]:
```

**Key differences:**
- ‚úÖ Stops and asks
- ‚úÖ Shows exactly what conflicts
- ‚úÖ Defaults to safe option
- ‚úÖ Your README is untouched

### 2. Report Conflicts for Manual Review

**Detailed conflict reporting:**

```bash
$ viperx new mypackage
Creating Python package 'mypackage'...

‚ö†Ô∏è  Found 3 existing files:

  1. README.md (modified 2 days ago)
     Existing: 1,234 bytes, custom content
     Template: 567 bytes, generic template
     ‚Üí Keeping existing (safer)

  2. .gitignore (modified 3 hours ago)
     Existing: 45 lines, custom patterns
     Template: 12 lines, Python defaults
     ‚Üí Keeping existing (safer)

  3. pyproject.toml (modified today)
     Existing: Contains custom build scripts
     Template: Basic ViperX template
     ‚Üí Keeping existing (safer)

üí° Tip: Use --diff to see template vs. existing
üí° Tip: Use --force to overwrite (dangerous!)

Created 15 new files, skipped 3 existing files.
```

**User is fully informed. No surprises.**

### 3. No Automatic Deletions

**ViperX never deletes files without explicit request.**

**Other tools:**
```bash
$ tool clean
Removing build artifacts...
Deleted: 847 files

# Oops, included your uncommitted work
```

**ViperX:**
```bash
$ viperx clean
Found potential artifacts:
  build/ (234 files)
  dist/ (12 files)
  __pycache__/ (89 files)

‚ö†Ô∏è  This will DELETE 335 files. Are you sure? [y/N]: n
Cancelled. No files deleted.

üí° Tip: Review with 'ls -R build/ dist/' first
üí° Tip: Use 'git clean -fdx' if you trust git
```

**Requires confirmation. Shows counts. Defaults to "no".**

### 4. Respects User's Work

**Philosophy:** The user's code is sacred.

**Example: Updating templates**

```bash
$ viperx update-template
Checking for template updates...
Found new template version: 2.0.0

This will update:
  - pyproject.toml template
  - .github/workflows/ci.yml template
  - mkdocs.yml template

‚ö†Ô∏è  Your customizations will NOT be overwritten
    (we only update files you haven't modified)

Files with local changes:
  ‚úó pyproject.toml (you added custom dependencies)
  ‚úì .github/workflows/ci.yml (unchanged, will update)
  ‚úó mkdocs.yml (you customized navigation)

Proceed? [y/N]:
```

**Smart updating:**
- ‚úÖ Detects local modifications
- ‚úÖ Only updates unchanged files
- ‚úÖ Preserves user customizations
- ‚úÖ Clear about what will change

### 5. `--force` Flags Require Confirmation

**Even force flags are safe by default:**

```bash
$ viperx new mypackage --force
‚ö†Ô∏è  WARNING: --force will overwrite existing files!

Files that will be OVERWRITTEN:
  1. README.md (1,234 bytes) ‚Üí DELETED
  2. .gitignore (789 bytes) ‚Üí DELETED
  3. pyproject.toml (2,345 bytes) ‚Üí DELETED

This action CANNOT be undone.

Type 'yes I want to overwrite' to confirm: no
Cancelled.
```

**Protection layers:**
1. `--force` flag required
2. Shows what will be destroyed
3. Requires typed confirmation (not just 'y')
4. Defaults to cancellation

**Even with `--force`, you have a chance to bail out.**

## Benefits in Detail

### 1. No Data Loss

**Traditional tool:**
```bash
$ tool init
# Silently overwrites 5 files
$ git diff
# "Oh no, my custom config is gone!"
```

**ViperX:**
```bash
$ viperx new mypackage
# Skips existing files, reports conflicts
$ git status
# No changes to tracked files ‚úÖ
```

### 2. Confidence to Experiment

**Developer thinking:**

‚ùå "I'm scared to run `tool init` because it might break things"
‚úÖ "I can safely run `viperx new` because it won't overwrite anything"

**Result:** More experimentation, faster learning.

### 3. Easier Debugging

**When something goes wrong:**

**Traditional tool:**
```bash
$ tool init
Something broke!

# What did the tool change?
# Which files were overwritten?
# How do I restore?
# No way to know!
```

**ViperX:**
```bash
$ viperx new mypackage
Created 15 files, skipped 3 conflicts.

# Exactly what was created: documented
# What was skipped: documented
# Nothing was destroyed: guaranteed
# Easy to understand what happened
```

### 4. Version Control Friendly

**Git workflow:**

```bash
# Existing project with uncommitted changes
$ git status
modified: README.md
modified: src/module.py

$ viperx new mypackage
‚ö†Ô∏è  Uncommitted changes detected
    We'll skip existing files to protect your work.

Created 10 new files, skipped 2 existing files.

$ git status
modified: README.md
modified: src/module.py
# ‚úÖ Your uncommitted work is safe!

new file: pyproject.toml
new file: src/mypackage/__init__.py
# Only new files added
```

**Safe to use mid-development. Won't destroy uncommitted work.**

### 5. Plays Well with CI/CD

**CI pipeline safety:**

```yaml
# .github/workflows/update.yml
jobs:
  auto-update:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Update ViperX templates
        run: viperx update-template
        # Safe: Won't overwrite customizations
      
      - name: Check for changes
        run: git diff --exit-code
        # Only fails if templates actually updated
```

**Won't cause surprise breakage in automated workflows.**

## Real-World Scenario

### The Team Onboarding Experience

**Company:** Mid-size startup, 20 developers

**Situation:** Adopting ViperX across multiple projects

#### Week 1: Initial Skepticism

**Senior Dev:** "Another tool that will break our existing projects?"

**Try ViperX:**
```bash
$ cd existing-api-project/
$ viperx new api
‚ö†Ô∏è  Found existing pyproject.toml
    Keeping your version. Template available at: templates/pyproject.toml.template

Created 8 new files, skipped 3 existing files.
```

**Senior Dev:** "Wait, it didn't break anything? Let me check..."
```bash
$ git diff
# Only new files added, nothing modified
```

**Senior Dev:** "Okay, this is actually safe. ‚úÖ"

#### Week 2: Junior Dev Onboards

**Junior Dev:** First Python project, nervous about tools

```bash
$ viperx new myservice
Creating Python package 'myservice'...
‚úì Created project structure

$ viperx new myservice
‚ö†Ô∏è  Project 'myservice' already exists!

Options:
  1. Cancel (safe, default)
  2. Create in a different directory
  3. Merge new files (skip conflicts)
  4. Overwrite everything (--force)

Choice [1]: 1
Cancelled. Your project is safe.
```

**Junior Dev:** "Oh, I ran it twice by accident. But nothing broke! ‚úÖ"

**Result:** Junior dev has confidence to experiment.

#### Week 3: Production Incident (Avoided)

**DevOps:** Updating production deployment scripts

```bash
$ cd production-deployment/
$ viperx new deployment-service
‚ö†Ô∏è  Found existing files:
  - config.yaml (contains production secrets)
  - scripts/deploy.sh (custom deployment logic)

These files will NOT be overwritten.

Created 5 new files, skipped 2 existing files.
```

**DevOps:** "Good, my production config is untouched. ‚úÖ"

**Alternative timeline (with destructive tool):**
```bash
$ cd production-deployment/
$ other-tool init
‚úì Created config.yaml  # ‚ùå Overwrote production config
# Production goes down, database credentials lost
# Hours of incident response
```

**ViperX avoided a production incident.**

#### Week 4: Team Adoption

**CTO's decision:**
> "ViperX is approved for all projects. It's the first scaffold tool I trust not to break things."

**Why?**
- ‚úÖ No data loss incidents
- ‚úÖ Junior devs can safely experiment
- ‚úÖ Senior devs trust it with existing projects
- ‚úÖ DevOps comfortable using in automation

## Safe Mode in Different Commands

### `viperx new`

**Safe defaults:**
```bash
$ viperx new mypackage
# Skips existing files
# Reports conflicts
# Creates only new files
```

**Force mode (still careful):**
```bash
$ viperx new mypackage --force
‚ö†Ô∏è  This will overwrite X files
Type 'yes I want to overwrite' to confirm:
```

### `viperx update`

**Safe defaults:**
```bash
$ viperx update
# Only updates unchanged files
# Skips files with local modifications
# Shows what will change
```

**Review mode:**
```bash
$ viperx update --diff
# Shows diff for each file
# Prompts for each change
# Can skip individual files
```

### `viperx clean`

**Safe defaults:**
```bash
$ viperx clean
# Shows what will be deleted
# Requires confirmation
# Defaults to 'no'
```

**Dry run:**
```bash
$ viperx clean --dry-run
Would delete:
  build/ (234 files)
  dist/ (12 files)
  __pycache__/ (89 files)

No files deleted (dry run).
```

### `viperx workspace`

**Safe defaults:**
```bash
$ viperx workspace add api
‚ö†Ô∏è  Directory 'api/' already exists
Options:
  1. Skip (keep existing)
  2. Merge (add missing files)
  3. Overwrite (dangerous!)

Choice [1]:
```

## Comparison with Other Tools

### Cookiecutter

**Behavior:**
```bash
$ cookiecutter template
project_name [my_project]: my_project
# If my_project/ exists: overwrites without asking
```

**ViperX:**
```bash
$ viperx new my_project
‚ö†Ô∏è  Project 'my_project' already exists
Choose action: [1] Cancel
```

### Yeoman

**Behavior:**
```bash
$ yo generator
# Asks file-by-file (tedious for 50 files)
Overwrite README.md? (Y/n)
Overwrite .gitignore? (Y/n)
# ... 50 more prompts
```

**ViperX:**
```bash
$ viperx new myproject
# Shows all conflicts at once
# Bulk decision (keep all existing, or force all)
# Not 50 individual prompts
```

### create-react-app

**Behavior:**
```bash
$ create-react-app my-app
# Requires empty directory or new directory
$ create-react-app .
# Error: Current directory is not empty
```

**ViperX:**
```bash
$ viperx new mypackage
# Works in existing directory
# Merges new files with existing
# Smart conflict resolution
```

### cargo init

**Behavior:**
```bash
$ cargo init
# Relatively safe, but limited conflict handling
# Will overwrite Cargo.toml
```

**ViperX:**
```bash
$ viperx new mypackage
# More granular: skips ALL existing files
# User explicitly opts-in to overwrites
```

## Edge Cases & Solutions

### 1. Partial Project Exists

**Scenario:** Some files exist, some don't.

```bash
$ ls
README.md
src/

$ viperx new mypackage
‚ö†Ô∏è  Found existing files: README.md, src/
    Missing files: pyproject.toml, .gitignore, tests/

Options:
  1. Add missing files only (safe) ‚úÖ Default
  2. Overwrite everything (dangerous)

Choice [1]: 1
‚úì Created pyproject.toml
‚úì Created .gitignore
‚úì Created tests/
‚ö†Ô∏è  Skipped: README.md, src/ (existing)

Project setup complete! 3 files added, 2 skipped.
```

**Smart merge: Adds what's missing, keeps what exists.**

### 2. Template Updates

**Scenario:** Template has new version with improvements.

```bash
$ viperx update
Checking for updates...
New template features available:
  - Better CI workflow
  - Type checking configuration
  - Security scanning

Files to update:
  ‚úì .github/workflows/ci.yml (no local changes)
  ‚úó pyproject.toml (you customized dependencies)
  ‚úì .pre-commit-config.yaml (no local changes)

Proceed with updating 2 files? [y/N]: y
‚úì Updated .github/workflows/ci.yml
‚úì Updated .pre-commit-config.yaml
‚ö†Ô∏è  Skipped pyproject.toml (has local changes)

üí° Review template diff: viperx update --diff pyproject.toml
```

**Selective updates: Only touch what's safe.**

### 3. Accidental Wrong Directory

**Scenario:** Ran command in wrong directory.

```bash
$ cd ~  # Oops, home directory
$ viperx new myproject
‚ö†Ô∏è  Current directory contains many files (234 files)
    This doesn't look like a project directory.

Create 'myproject' here? This seems unusual.
  Current: /home/user (234 existing files)
  Suggested: /home/user/projects/myproject

Continue anyway? [y/N]: n
Cancelled.

üí° Tip: cd to your projects directory first
```

**Smart detection: Warns when context seems wrong.**

### 4. Corrupted State

**Scenario:** Previous run was interrupted.

```bash
$ viperx new mypackage
‚ö†Ô∏è  Found incomplete project setup:
  ‚úì pyproject.toml (created)
  ‚úì README.md (created)
  ‚úó src/ (missing)
  ‚úó tests/ (missing)

Looks like a previous run was interrupted.

Options:
  1. Resume (add missing files) ‚úÖ Default
  2. Start over (remove and recreate)
  3. Cancel

Choice [1]: 1
‚úì Created src/
‚úì Created tests/
‚úì Keeping pyproject.toml
‚úì Keeping README.md

Project setup complete!
```

**Graceful recovery: Resumes from interruption.**

### 5. Complex Merges

**Scenario:** Existing project, want to add ViperX patterns.

```bash
$ viperx new mypackage --merge
Merging ViperX patterns into existing project...

Analysis:
  Existing structure: Flat layout
  ViperX structure: src/ layout

Migration options:
  1. Add ViperX files alongside existing ‚úÖ Safe
  2. Migrate to src/ layout (moves files)
  3. Cancel

Choice [1]: 1

‚úì Created pyproject.toml
‚úì Created .github/workflows/
‚úì Created tests/ (your existing tests/ kept as tests.old/)
‚ö†Ô∏è  Skipped: README.md (keeping yours)

Migration complete! Review changes:
  git diff
```

**Intelligent merging: Detects patterns, suggests migration.**

## Implementation Details

### Conflict Detection

**ViperX checks:**
1. File exists?
2. File modified recently?
3. File has uncommitted changes?
4. File content differs from template?

**Logic:**
```python
def should_skip_file(file_path: Path, template_content: str) -> bool:
    """Decide if file should be skipped to preserve user work."""
    
    # 1. File doesn't exist ‚Üí create it
    if not file_path.exists():
        return False
    
    # 2. File exists but content identical ‚Üí skip (no need to overwrite)
    if file_path.read_text() == template_content:
        return True
    
    # 3. File exists and differs ‚Üí SKIP (preserve user work)
    return True  # Safe default: preserve existing

def create_project_safely(files_to_create: dict):
    """Create project files, never overwriting existing content."""
    
    created = []
    skipped = []
    
    for file_path, content in files_to_create.items():
        if should_skip_file(file_path, content):
            skipped.append(file_path)
        else:
            file_path.write_text(content)
            created.append(file_path)
    
    # Report results
    print(f"‚úì Created {len(created)} files")
    if skipped:
        print(f"‚ö†Ô∏è  Skipped {len(skipped)} existing files:")
        for path in skipped:
            print(f"  - {path}")
```

### Force Mode Protection

**Even with --force:**
```python
def force_overwrite_with_confirmation(files: list):
    """Require explicit confirmation even with --force."""
    
    print("‚ö†Ô∏è  WARNING: This will overwrite existing files!")
    print(f"\nFiles to be DELETED:")
    
    for path in files:
        size = path.stat().st_size
        print(f"  - {path} ({size} bytes)")
    
    print("\n‚ö†Ô∏è  This action CANNOT be undone.")
    print("‚ö†Ô∏è  Consider backing up first: git commit -am 'backup'")
    
    confirmation = input("\nType 'yes I want to overwrite' to confirm: ")
    
    if confirmation != "yes I want to overwrite":
        print("Cancelled. No files modified.")
        return False
    
    return True
```

### Dry Run Mode

**Preview changes:**
```python
def dry_run_mode():
    """Show what would be changed without changing anything."""
    
    print("DRY RUN MODE (no files will be modified)\n")
    
    # Simulate all operations
    for file_path, content in files_to_create.items():
        if file_path.exists():
            print(f"‚ö†Ô∏è  Would skip: {file_path} (exists)")
        else:
            print(f"‚úì Would create: {file_path}")
    
    print("\nNo files were modified (dry run).")
    print("Remove --dry-run to apply changes.")
```

## Best Practices

### 1. Always Start Safe

```bash
# ‚úÖ Good: Try without force first
$ viperx new mypackage
# Review conflicts, then decide

# ‚ùå Bad: Start with force
$ viperx new mypackage --force
# Might destroy work before you realize
```

### 2. Use Version Control

```bash
# ‚úÖ Good: Commit before running ViperX
$ git commit -am "Before running viperx"
$ viperx new mypackage
$ git diff  # See exactly what ViperX did

# ‚ùå Bad: Uncommitted work
$ viperx new mypackage --force
# If something goes wrong, can't revert
```

### 3. Leverage Dry Run

```bash
# ‚úÖ Good: Preview first
$ viperx clean --dry-run
# Review what would be deleted
$ viperx clean  # Now run for real

# ‚ùå Bad: Delete without preview
$ viperx clean --force
# Oops, deleted something important
```

### 4. Read Conflict Reports

```bash
# ‚úÖ Good: Read the output
$ viperx new mypackage
‚ö†Ô∏è  Skipped: README.md
# "Oh, I should review my README vs template"

# ‚ùå Bad: Ignore warnings
$ viperx new mypackage
# ... doesn't read output ...
# Wonders why project is incomplete
```

## Learning More

### Official Resources
- [ViperX Safety Docs](../configuration.md#safety-features) - Safety configuration
- [Fail-Safe Design](https://en.wikipedia.org/wiki/Fail-safe) - Engineering principle
- [Defensive Programming](https://en.wikipedia.org/wiki/Defensive_programming) - Related concepts

### Related Topics
- [Why config-in-package?](config-in-package.md) - Safe config placement
- [Why src/ layout?](src-layout.md) - Safe project structure
- [Version Control Best Practices](https://git-scm.com/book/en/v2) - Git safety

### Tools with Safe Defaults
- Git (requires explicit force flags)
- Rust's cargo (ownership prevents errors)
- TypeScript (strict mode prevents bugs)

---

**Next Steps:**
1. Try: `viperx new test-project` in an existing directory
2. Observe: How conflicts are reported
3. Experiment: Use `--dry-run` to preview changes
4. Practice: Commit before running ViperX commands
5. Explore: Check `viperx --help` for safety options

*"Safe mode: Respect the user's work, always."*
